#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <queue>
#include <unordered_map>
using namespace std;

/**********************************************************************************************************
方法1：枚举法（超时）10^9个数据，枚举没戏

说明：

时间复杂度与空间复杂度：O(n) O(1)

涉及到的知识点：

***********************************************************************************************************/
class Solution {
public:
    int countOdds(int low, int high) {
        int ans = 0;
        for (int i = low; i <= high; i++) {
            if (i & 0x01) ans++;
        }
        return ans;
    }
};

/**********************************************************************************************************
方法2：归纳法

说明：
    在纸上列举数据，发现只有当两个全是偶数时，返回的是(high - low) / 2，否则一律返回1 + (high - low) / 2

时间复杂度与空间复杂度：O(1) O(1)

涉及到的知识点：

***********************************************************************************************************/
class Solution {
public:
    int countOdds(int low, int high) {
        if (!(low & 0x01) && !(high & 0x01)) {
            return (high - low) / 2;
        }
        else return 1 + (high - low) / 2;
    }
};

/**********************************************************************************************************
方法3：组合法

说明：
    [1,n]个数据中，奇数个数据共有int((1 + n) / 2)个
    那么[low,high]等价于[1,high] - [1,low)

时间复杂度与空间复杂度：O(1) O(1)

涉及到的知识点：

***********************************************************************************************************/
class Solution {
public:
    int countOdds(int low, int high) {
        int num2 = (high + 1) / 2;
        int num1 = low / 2;
        return num2 - num1;
    }
};