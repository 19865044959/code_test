/*
时间限制:?1 Sec??内存限制:?128 MB

题目描述

有n堆糖果（2≤n≤200），排成一行，编号分别为1,2,…n。
已知每堆糖果有一定的颗数，且颗数之和均为n的倍数。移动各堆中的任意颗糖果，使每堆的数量达到相同，且移动次数最少。
? 移动规则：
? 每次可以移动任意的糖果颗数，第1堆可以移向第2堆，第2堆可以移向第1堆或第3堆,。。。。。。 第n 堆只可以移向第n -1堆。
例如，当n=4时：
堆号? ? ? 1? ? ?2? ? ?3? ? ?4?
颗数? ? ? 9? ? ?8? ? ?17? ? 6
移动的方法有许多种， 其中的一种方案：
① 第3堆向第4堆移动4颗，成为：9? ? 8? ? 13? ? 10
② 第3堆向第2堆移动3颗，成为：9? ? 11? ?10? ? 10
③ 第2堆向第1堆移动1颗，成为：10? ?10? ?10? ? 10
经过三次移动，每堆都成为10颗。

输入

有两行。
第一行一个整数n。
第二行n个整数，用空格分隔。

输出

一个整数（表示最少移动次数）。
*/

/*
	我的想法：先求出aver，然后每次求出最大值对应的下标，maxIdx，同时维护一个最大值前面的值之和数组，把最大值 - aver多出来的部分往
	左边移，如果左边够了，就往右边移，通过率37.5% ×
*/


/*
	别人思路：贪心算法，从第一个数开始，如果数不为aver，那么就向右边的借，直到倒数第二个数为止
*/

#include<vector>
#include<iostream>
using namespace std;

int main() {
	int n;
	while (cin >> n) {
		vector<int> nums(n, 0);
		long long sum = 0;
		for (int i = 0; i < n; i++) {
			cin >> nums[i];
			sum += nums[i];
		}
		int aver = sum / n;
		int cnt = 0;
		for (int i = 0; i < n - 1; i++) {
			int delta = nums[i] - aver;
			if (delta == 0) continue;
			else {
				nums[i + 1] += delta;
				cnt++;
			}
		}
		cout << cnt << endl;
	}
	return 0;
}

/*
4
9　8　17　6
*/