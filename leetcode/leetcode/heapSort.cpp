#include <iostream>
#include <vector>
using std::vector;
using std::swap;

/**********************************************************************************************************
方法：堆排序

说明：
	快排输入的是low 与high，即索引值：low = 0;  high = c.size() - 1
	堆排序输入的是长度n，即n = c.size()

时间复杂度与空间复杂度：O(nlogn)  O(1)

涉及到的知识点：
	1. 堆这个数据结构：与二叉树不同，二叉树是右儿子大于双亲节点，左儿子小于双亲节点
		堆实现的是：父亲节点严格大于子节点(大顶堆)/父亲节点严格小于子节点(小顶堆)
	2. 完全二叉树的几个性质：
		设已知一个数组nums，其元素是一个完全二叉树的层序遍历，那么：
		如果一个节点，对应下标为i，那么：
			①i == 0 说明是根节点，没有双亲结点。
			②除了①以外，其双亲节点为i / 2，用这个性质可以非常容易找出最后一个有孩子的节点：(n - 1) / 2
	
		如果一个节点下标为i，那么：
			①if(2 * i + 1 < n)，则下标i的左孩子下标为2 * i + 1
			②if(2 * i + 2 < n)，则下标i的右孩子下标为2 * i + 2
***********************************************************************************************************/
//堆处理化函数说明：选定a[i]作为根节点，对这棵树进行一遍堆处理化
void heapify(vector<int>& a, int i, int n) {
	int tmp = a[i];
	for (int j = 2 * i + 1; j < n; j = 2 * i + 1) {
		if (j + 1 < n && a[j] < a[j + 1]) j++;
		if (tmp >= a[j]) break;
		a[i] = a[j];
		i = j;
	}
	a[i] = tmp;
}

void heapSort(vector<int>& a, int n) {
	//构造大顶堆
	for (int i = (n - 1) / 2; i >= 0; i--) { // i = floor(n / 2) - 1是孩子节点的最大值，从每个有孩子的节点开始，进行堆处理化
		heapify(a, i, n);
	}
	for (int i = n - 1; i > 0; i--) {
		swap(a[0], a[i]);
		heapify(a, 0, i); //注意这里是i而不是i-1，原因是i = n - 1，而heapify的输入是长度n而不是最大索引n - 1
	}
}

int main() {
	vector<int> a{ 4,2,14,661,443,224,11243,2,44 }; //二叉树的层序遍历
	heapSort(a, a.size());
	return 0;
}


