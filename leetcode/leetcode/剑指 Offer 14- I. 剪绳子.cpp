#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <queue>
#include <unordered_map>
using namespace std;

/**********************************************************************************************************
方法：动态规划

说明：

时间复杂度与空间复杂度：O(n) O(1)

涉及到的知识点：

自上而下的思考方式（不宜做答案，复杂度太高）
    设f(n)是n长度绳子最大乘积，分4种情况：(设j = n - i)
    1. i与j均不可再分 f(n) = i * j
    2. i可再分，j不可再分，f(n) = f(i) * j;
    3. i不可再分，j可再分：f(n) = i * f(j);
    4. i、j均可再分：f(n) = f(i) * f(j);

    整理：f(n) = max(i, f(i)) * max(j, f(j));
    自下而上的解题思路：先求出
    f(0) = f(1) = 0
    f(2) = 1
    从下往上依次求解即可

***********************************************************************************************************/
class Solution {
public:
    int cuttingRope(int n) {
        vector<int> dp(n + 1);
        dp[0] = dp[1] = 0;
        dp[2] = 1;
        for (int i = 3; i < n + 1; i++) {
            for (int j = 1; j < i; j++) {
                dp[i] = max(dp[i], max(j, dp[j]) * max(i - j, dp[i - j]));
            }
        }
        return dp[n];
    }
};

/**********************************************************************************************************
方法：算术平均数+几何平均数

说明：
    首先，根据算术平均数 >= 几何平均数，当且仅当所有元素相等时取等号可知，要想在相同长度绳子取得最大乘积，那么截取的绳子一定是等长的
    其次，设定长为a的绳子，剪成b段，一段为x长，那么有a = bx，y(x) = x ^ b = x ^ (a / x) 求y的最大值即可，求出驻点为e = 2.71828 = 3，故每段取3才获取最大的长度乘积
    算法流程：a = 3 * b + c
        1. 当c = 0时，直接返回3^b
        2. 当c = 1时，返回3^(b - 1) * (2 * 2) 因为1*3 < 2*2
        3. 当c = 2时，返回3^b * 2

时间复杂度与空间复杂度：O(1) O(1)

涉及到的知识点：

***********************************************************************************************************/
class Solution {
public:
    int cuttingRope(int n) {
        int count = 0;
        if (n <= 3) return n - 1;
        int b = n / 3;
        int c = n % 3;
        if (c == 0) return pow(3, b);
        else if (c == 1) return pow(3, b - 1) * 4;
        else return pow(3, b) * 2;
    }
};